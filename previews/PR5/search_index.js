var documenterSearchIndex = {"docs":
[{"location":"#FoldsThreads.jl","page":"FoldsThreads.jl","title":"FoldsThreads.jl","text":"","category":"section"},{"location":"","page":"FoldsThreads.jl","title":"FoldsThreads.jl","text":"Modules = [FoldsThreads]\nPrivate = false","category":"page"},{"location":"#FoldsThreads.FoldsThreads","page":"FoldsThreads.jl","title":"FoldsThreads.FoldsThreads","text":"FoldsThreads: Extra threaded executors for JuliaFolds/*.jl\n\n(Image: Dev) (Image: GitHub Actions)\n\nFoldsThreads.jl provides extra thread-based executors usable with various JuliaFolds/*.jl packages such as Transducers.jl and FLoops.jl.\n\n                                  Executors\n                           ,----------------------.\n     Algorithms            |    FoldsThreads.jl    |         Data structures\n,------------------.       |-----------------------|       ,-----------------.\n|  FLoops,         |       |  ThreadedEx*          |       |  Array,         |\n|  Folds,          |       |  WorkStealingEx,      |       |  Tables,        |\n|  Transducers,    |  ---  |  DepthFirstEx,        |  ---  |  FGenerators,   |\n|  OnlineStats,    |       |  TaskPoolEx,          |       |  Dict,          |\n|  DataTools, ...  '       |  NondeterministicEx,  |       |  Set, ...       |\n`------------------'       |  ...                  |       `-----------------'\n                           `-----------------------'\n\n(* ThreadedEx is the default executor provided by Transducers.jl)\n\nWorkStealingEx implements work stealing (continuation stealing). Useful for load-balancing.\nDepthFirstEx implements depth-first scheduling. Useful for findfirst-type computations.\nTaskPoolEx: Task pool executor. Useful for fine execution control (e.g., back pressure and \"background\" threads).\nNondeterministicEx: An executor for parallelizing computations with non-parallelizable iterators.\n\n\n\n\n\n","category":"module"},{"location":"#FoldsThreads.DepthFirstEx","page":"FoldsThreads.jl","title":"FoldsThreads.DepthFirstEx","text":"DepthFirstEx(; [simd,] [basesize])\n\nDepth-first scheduling for parallel execution. Useful for findfirst-type of computation.\n\nExamples\n\njulia> using FoldsThreads\n       using Folds\n\njulia> Folds.sum(i -> gcd(i, 42), 1:1000_000, DepthFirstEx())\n4642844\n\nExtended help\n\nDepthFirstEx schedules chunks of size roughly equal to basesize in the order that each chunk appears in the input collection. However, the base case computation does not wait for all the tasks to be scheduled. This approach performs better than a more naive approach where the all tasks are scheduled at once before the reduction starts. DepthFirstEx is useful for reductions that can terminate early (e.g., findfirst, @floop with break).\n\nMore examples\n\njulia> using FoldsThreads\n       using FLoops\n\njulia> @floop DepthFirstEx() for x in 1:1000_000\n           y = gcd(x, 42)\n           @reduce(acc += y)\n       end\n       acc\n4642844\n\nKeyword Arguments\n\nbasesize: The size of base case.\nsimd: false, true, :ivdep, or Val of one of them.  If true/:ivdep, the inner-most loop of each base case is annotated by @simd/@simd ivdep.  Use a plain loop if false (default).\n\n\n\n\n\n","category":"type"},{"location":"#FoldsThreads.NonThreadedEx","page":"FoldsThreads.jl","title":"FoldsThreads.NonThreadedEx","text":"NonThreadedEx(; [simd,] [basesize])\n\nSingle-threaded executor with call tree similar to divide-and-conquer type of threaded executors. It is useful for debugging, testing, and benchmarking.\n\n\n\n\n\n","category":"type"},{"location":"#FoldsThreads.NondeterministicEx","page":"FoldsThreads.jl","title":"FoldsThreads.NondeterministicEx","text":"NondeterministicEx(; [simd,] [basesize,] [ntasks,])\n\nPipelined batched reduction for parallelizing computations with non-parallelizable collections (e.g., Channel, Iterators.Stateful).\n\nThis is a simple wrapper of NondeterministicThreading transducer. Use NondeterministicThreading directly for explicit control on what transducers are parallelized.\n\nExamples\n\njulia> using FoldsThreads\n       using Folds\n\njulia> partially_parallelizable(seq) = (gcd(y, 42) for x in seq for y in 1:10000x);\n\njulia> Folds.sum(partially_parallelizable(Iterators.Stateful(1:100)), NondeterministicEx())\n234462500\n\nExtended help\n\nIn the above example, we can run gcd(y, 42) (mapping), for y in 1:10000x (flattening), and + for sum (reduction) in parallel even though the iteration of Iterators.Stateful(1:100) is not parallelizable. Note that, as indicated in the example, the computation per each iteration of the non-parallelizable collection should be very CPU-intensive in order for NondeterministicEx to show any kind of performance benefits.\n\nSame computation using FLoops.jl:\n\njulia> using FoldsThreads\n       using FLoops\n\njulia> @floop NondeterministicEx() for x in Iterators.Stateful(1:100)\n           for y in 1:10000x\n               z = gcd(y, 42)\n               @reduce(acc += z)\n           end\n       end\n       acc\n234462500\n\nNotes\n\n\"Nondeterministic\" in the name indicates that the result of the reduction is not deterministic (i.e., schedule-dependent) if the reducing function is only approximately associative (e.g., + on floats). For computations (e.g., Folds.collect) that uses strictly associative operations (e.g., \"vcat\"), the result does not depend on the particular scheduling decision of Julia runtime. To be more specific, this executor uses the scheduling that does not produce deterministic divide-and-conquer \"task\" graph. Instead, the shape of the graph is determined by the particular timing of each computation at run-time.\n\nKeyword Arguments\n\nbasesize: The size of base case.\nntasks: The number of tasks used by this executor.\nsimd: false, true, :ivdep, or Val of one of them.  If true/:ivdep, the inner-most loop of each base case is annotated by @simd/@simd ivdep.  Use a plain loop if false (default).\n\n\n\n\n\n","category":"type"},{"location":"#FoldsThreads.TaskPoolEx","page":"FoldsThreads.jl","title":"FoldsThreads.TaskPoolEx","text":"TaskPoolEx(; [simd,] [basesize,] [ntasks,] [background,])\n\nExecutor using pooled tasks for reduction. Useful for reductions with I/O and managing back pressure. With background = true, it can also be used to isolate throughput-oriented tasks and use the primary thread for latency-oriented tasks.\n\nExamples\n\njulia> using FoldsThreads\n       using Folds\n\njulia> Folds.sum(i -> gcd(i, 42), 1:1000_000, TaskPoolEx())\n4642844\n\nExtended help\n\nWorker tasks are pooled (for each executor) so that the number of Julia Tasks used for a reduction can be much smaller than input_length รท basesize. This strategy is used mainly for limiting resource (e.g., memory) required by the reduction than for load-balancing. WorkStealingEx performs better for load-balancing of compute-intensive reductions.\n\nNOTE: This executor is inspired by ThreadPools.jl. The hack for assigning a task to a dedicated thread is stolen from ThreadPools.jl.\n\nwarning: Warning\nIt is highly discouraged to use this executor in Julia packages; especially those that are used as libraries rather than end-user applications. This is because the whole purpose of this executor is to prevent Julia runtime from doing the right thing for managing tasks. Ideally, the library user should be able to pass an executor as an argument so that your library function can be used with any executors including TaskPoolEx.\n\nMore examples\n\njulia> using FoldsThreads\n       using FLoops\n\njulia> @floop TaskPoolEx() for x in 1:1000_000\n           y = gcd(x, 42)\n           @reduce(acc += y)\n       end\n       acc\n4642844\n\nKeyword Arguments\n\nbackground = false: If background == true, do not run tasks on threadid() == 1.\nntasks: The number of tasks to be used.\nbasesize: The size of base case.\nsimd: false, true, :ivdep, or Val of one of them.  If true/:ivdep, the inner-most loop of each base case is annotated by @simd/@simd ivdep.  Use a plain loop if false (default).\n\n\n\n\n\n","category":"type"},{"location":"#FoldsThreads.WorkStealingEx","page":"FoldsThreads.jl","title":"FoldsThreads.WorkStealingEx","text":"WorkStealingEx(; [simd,] [basesize])\n\nWork-stealing scheduling for parallel execution. Useful for load-balancing.\n\nExamples\n\njulia> using FoldsThreads\n       using Folds\n\njulia> Folds.sum(i -> gcd(i, 42), 1:1000_000, WorkStealingEx())\n4642844\n\nExtended help\n\nWorkStealingEx implements work stealing scheduler (in particular, continuation stealing) for Transducers.jl and other JuliaFolds/*.jl packages. Worker tasks are cached and re-used so that the number of Julia Tasks used for a reduction can be much smaller than input_length รท basesize. This has a positive impact on computations that require load-balancing since this does not incur the overhead of spawning tasks.\n\nNOTE: WorkStealingEx is more complex and experimental than the default multi-thread executor ThreadedEx.\n\nMore examples\n\njulia> using FoldsThreads\n       using FLoops\n\njulia> @floop WorkStealingEx() for x in 1:1000_000\n           y = gcd(x, 42)\n           @reduce(acc += y)\n       end\n       acc\n4642844\n\nKeyword Arguments\n\nbasesize: The size of base case.\nsimd: false, true, :ivdep, or Val of one of them.  If true/:ivdep, the inner-most loop of each base case is annotated by @simd/@simd ivdep.  Use a plain loop if false (default).\n\n\n\n\n\n","category":"type"}]
}
