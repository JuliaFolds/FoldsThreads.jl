var documenterSearchIndex = {"docs":
[{"location":"#FoldsThreads.jl","page":"FoldsThreads.jl","title":"FoldsThreads.jl","text":"","category":"section"},{"location":"","page":"FoldsThreads.jl","title":"FoldsThreads.jl","text":"Modules = [FoldsThreads]\nPrivate = false","category":"page"},{"location":"#FoldsThreads.FoldsThreads","page":"FoldsThreads.jl","title":"FoldsThreads.FoldsThreads","text":"FoldsThreads: Extra threaded executors for JuliaFolds/*.jl\n\nFoldsThreads.jl provides extra thread-based executors usable with various JuliaFolds/*.jl packages such as Transducers.jl and FLoops.jl.\n\n                                  Executors\n                           ,----------------------.\n     Algorithms            |    FoldsThreads.jl    |         Data structures\n,------------------.       |-----------------------|       ,-----------------.\n|  FLoops,         |       |  ThreadedEx*          |       |  Array,         |\n|  Folds,          |       |  WorkStealingEx,      |       |  Tables,        |\n|  Transducers,    |  ---  |  DepthFirstEx,        |  ---  |  FGenerators,   |\n|  OnlineStats,    |       |  TaskPoolEx,          |       |  Dict,          |\n|  DataTools, ...  '       |  NondeterministicEx,  |       |  Set, ...       |\n`------------------'       |  ...                  |       `-----------------'\n                           `-----------------------'\n\n(* ThreadedEx is the default executor provided by Transducers.jl)\n\nWorkStealingEx implements work stealing (continuation stealing). Useful for load-balancing.\nDepthFirstEx implements depth-first scheduling. Useful for findfirst-type computations.\nTaskPoolEx: Task pool executor. Useful for fine execution control (e.g., back pressure and \"background\" threads).\nNondeterministicEx: An executor for parallelizing computations with non-parallelizable iterators.\n\n\n\n\n\n","category":"module"},{"location":"#FoldsThreads.DepthFirstEx","page":"FoldsThreads.jl","title":"FoldsThreads.DepthFirstEx","text":"DepthFirstEx(; [simd,] [basesize])\n\nDepth-first scheduling for parallel execution. Useful for findfirst-type of computation.\n\nExamples\n\njulia> using FoldsThreads\n       using Folds\n\njulia> Folds.sum(i -> gcd(i, 42), 1:1000_000, DepthFirstEx())\n4642844\n\nExtended help\n\nDepthFirstEx schedules chunks of size roughly equal to basesize in the ordered that each chunk appears in the input collection. The basecase computation does not wait for all the tasks to be scheduled. This approach performs better than a more naive approach where the all tasks are scheduled before the reduction starts.  DepthFirstEx is useful for reductions that can terminate early (e.g., findfirst, @floop with break).\n\nKeyword Arguments\n\nbasesize: The size of base case.\nsimd: false, true, :ivdep, or Val of one of them.  If true/:ivdep, the inner-most loop of each base case is annotated by @simd/@simd ivdep.  Use a plain loop if false (default).\n\nMore examples\n\njulia> using FoldsThreads\n       using FLoops\n\njulia> @floop DepthFirstEx() for x in 1:1000_000\n           y = gcd(x, 42)\n           @reduce(acc += y)\n       end\n       acc\n4642844\n\n\n\n\n\n","category":"type"},{"location":"#FoldsThreads.NondeterministicEx","page":"FoldsThreads.jl","title":"FoldsThreads.NondeterministicEx","text":"NondeterministicEx(; [simd,] [basesize,] [ntasks,])\n\nBatched parallel reduction for non-parallelizable collections (e.g., Channel, Iterators.Stateful).\n\nThis is a simple wrapper of NondeterministicThreading transducer. Use NondeterministicThreading directly for explicit control on what transducers are parallelized.\n\nExamples\n\njulia> using FoldsThreads\n       using Folds\n\njulia> partially_parallelizable(seq) = (gcd(y, 42) for x in seq for y in 1:10000x);\n\njulia> Folds.sum(partially_parallelizable(Iterators.Stateful(1:100)), NondeterministicEx())\n234462500\n\nIn the above example, we can run gcd(y, 42) (mapping), for y in 1:10000x (flattening), and + for sum (reduction) in parallel even though the iteration of Iterators.Stateful(1:100) is not parallelizable. Note that, as indicated in the example, the computation per each iteration of the non-parallelizable collection should be very CPU-intensive in order for NondeterministicEx to show any kind of performance benefits.\n\nSame computation using FLoops.jl:\n\njulia> using FoldsThreads\n       using FLoops\n\njulia> @floop NondeterministicEx() for x in Iterators.Stateful(1:100)\n           for y in 1:10000x\n               z = gcd(y, 42)\n               @reduce(acc += z)\n           end\n       end\n       acc\n234462500\n\n\n\n\n\n","category":"type"},{"location":"#FoldsThreads.TaskPoolEx","page":"FoldsThreads.jl","title":"FoldsThreads.TaskPoolEx","text":"TaskPoolEx(; [simd,] [basesize,] [ntasks,] [background,])\n\nExecutor using pooled tasks for reduction. Useful for reductions with I/O and managing back pressure. With background = true, it can also be used to isolate throughput-oriented tasks and use the primary thread for latency-oriented tasks.\n\nExamples\n\njulia> using FoldsThreads\n       using Folds\n\njulia> Folds.sum(i -> gcd(i, 42), 1:1000_000, TaskPoolEx())\n4642844\n\nExtended help\n\nWorker tasks are pooled (for each executor) so that the number of Julia Tasks used for a reduction can be much smaller than input_length รท basesize. This strategy is used mainly for limiting resource (e.g., memory) required by the reduction than for load-balancing. WorkStealingEx performs better for load-balancing of compute-intensive reductions.\n\nNOTE: This executor is inspired by ThreadPools.jl. The hack for assigning a task to a dedicated thread is stolen from ThreadPools.jl.\n\nwarning: Warning\nIt is highly discouraged to use this executor in Julia packages; especially those that are used as libraries rather than end-user applications. This is because the whole purpose of this executor is to prevent Julia runtime from doing the right thing for managing tasks. Ideally, the library user should be able to pass an executor as an argument so that your library function can be used with any executors including TaskPoolEx.\n\nKeyword Arguments\n\nbackground = false: Do not run tasks on threadid() == 1.\nntasks: The number of tasks to be used.\nbasesize: The size of base case.\nsimd: false, true, :ivdep, or Val of one of them.  If true/:ivdep, the inner-most loop of each base case is annotated by @simd/@simd ivdep.  Use a plain loop if false (default).\n\nMore examples\n\njulia> using FoldsThreads\n       using FLoops\n\njulia> @floop TaskPoolEx() for x in 1:1000_000\n           y = gcd(x, 42)\n           @reduce(acc += y)\n       end\n       acc\n4642844\n\n\n\n\n\n","category":"type"},{"location":"#FoldsThreads.WorkStealingEx","page":"FoldsThreads.jl","title":"FoldsThreads.WorkStealingEx","text":"WorkStealingEx(; [simd,] [basesize])\n\nWork-stealing scheduling for parallel (but not concurrent) execution. Useful for load-balancing.\n\nExamples\n\njulia> using FoldsThreads\n       using Folds\n\njulia> Folds.sum(i -> gcd(i, 42), 1:1000_000, WorkStealingEx())\n4642844\n\nExtended help\n\nWorkStealingEx implements work stealing scheduler for Transducers.jl and other JuliaFolds/*.jl packages. Worker tasks are pooled (for each executor) so that the number of Julia Tasks used for a reduction can be much smaller than input_length รท basesize. This has a positive impact for reduction that requires load-balancing since this does not incur the overhead of spawning tasks. However, as the worker tasks are occupied by a base case until the base case is fully reduced, the user functions (reducing functions and transducers) cannot use concurrency primitives such as channels and semaphores to communicate within them. See below for discussion on usable concurrency patterns.\n\nNOTE: WorkStealingEx is more experimental than the default multi-thread executor ThreadedEx. Importantly, WorkStealingEx still does not perform well than ThreadedEx for parallel computation that does not require load-balancing.\n\nKeyword Arguments\n\nbasesize: The size of base case.\nsimd: false, true, :ivdep, or Val of one of them.  If true/:ivdep, the inner-most loop of each base case is annotated by @simd/@simd ivdep.  Use a plain loop if false (default).\n\nMore examples\n\njulia> using FoldsThreads\n       using FLoops\n\njulia> @floop WorkStealingEx() for x in 1:1000_000\n           y = gcd(x, 42)\n           @reduce(acc += y)\n       end\n       acc\n4642844\n\nPossible concurrency primitive usages\n\nEach channel is used solely for consuming or producing items (not both):\nUser functions that only consumes items from channels that are produced by Tasks outside the reduction.\nUser functions that only produces items to channels that have enough buffer size or are consumed by Tasks outside the reduction.\nLocks that are acquired and released within an iteration.\n\n\n\n\n\n","category":"type"}]
}
